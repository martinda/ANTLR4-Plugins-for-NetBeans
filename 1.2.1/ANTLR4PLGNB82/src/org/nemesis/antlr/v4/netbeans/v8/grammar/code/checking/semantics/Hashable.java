package org.nemesis.antlr.v4.netbeans.v8.grammar.code.checking.semantics;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import org.openide.util.Exceptions;

/**
 * Allows us to hash a GenericExtractorBuilder and its contents in a detailed
 * way, so if extractions are cached on disk, and the code changes, we don't
 * load caches that were generated by a differently configured extractor, since
 * those contents will not be what the code now expects.
 * <p>
 * For the purposes we use this for, this code does what it is supposed to with
 * Lambdas, <i>assuming the lambdas used to create the extractor are static
 * method references, and not instance methods of an object whose
 * toString()/hashCode() will differ across runs.</i>. The only thing we are
 * interested in here is always producing the same hash value if <i>the same
 * code</i> constructed it.
 * </p>
 * If you use custom types which are not lambdas for callbacks, or other custom
 * types in builders for creating an extraction, ensure that their hashCode()
 * and toString() are consistent, or the implement Hashable and hash the same
 * way if they have the same configuration.
 *
 * @author Tim Boudreau
 */
public interface Hashable {

    default void hashInto(Hasher hasher) {
        // Not great for lambdas, but short of serializable and serializing
        // them, will have to do
        hasher.writeString(toString());
    }

    public static final class Hasher {

        private final ByteArrayOutputStream out = new ByteArrayOutputStream(1024);

        Hasher() {
        }

        public String toString() {
            return new String(out.toByteArray(), UTF_8);
        }

        public Hasher hashObject(Object obj) {
            if (obj == null) {
                writeInt(0);
                return this;
            }
            if (obj instanceof Hashable) {
                ((Hashable) obj).hashInto(this);
            } else {
                writeInt(obj.hashCode());
                writeString(obj.toString());
            }
            return this;
        }

        public String hash() {
            try {
                MessageDigest md = MessageDigest.getInstance("SHA-1");
                byte[] digest = md.digest(out.toByteArray());
                return Base64.getUrlEncoder().encodeToString(digest);
            } catch (NoSuchAlgorithmException ex) {
                Exceptions.printStackTrace(ex);
            }
            return null;
        }

        public Hasher writeIntArray(int[] vals) throws IOException {
            ByteBuffer bb = ByteBuffer.allocate(vals.length * (Integer.SIZE / 8));
            for (int i = 0; i < vals.length; i++) {
                bb.putInt(i);
            }
            out.write(bb.array());
            return this;
        }

        public Hasher writeString(String val) {
            try {
                out.write(val.getBytes(UTF_8));
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }
            return this;
        }

        public Hasher writeInt(int val) {
            ByteBuffer bb = ByteBuffer.allocate(Integer.SIZE / 8);
            bb.putInt(val);
            try {
                out.write(bb.array());
            } catch (IOException ex) {
                Exceptions.printStackTrace(ex);
            }
            return this;
        }
    }
}
