/*
BSD License

Copyright (c) 2016-2018, Frédéric Yvon Vinet, Tim Boudreau
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* The name of its author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
OF SUCH DAMAGE.
 */
package org.nemesis.debug.ui.trackable;

import com.mastfrog.util.strings.Strings;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.JList;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.ListCellRenderer;
import javax.swing.Timer;
import javax.swing.UIManager;
import org.nemesis.debug.api.Trackables;
import org.nemesis.debug.ui.AntlrPluginDebugTopComponent;
import org.netbeans.api.editor.mimelookup.MimeLookup;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.awt.HtmlRenderer;
import org.openide.awt.StatusDisplayer;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.openide.util.Lookup;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.openide.util.RequestProcessor;
import org.openide.windows.Mode;
import org.openide.windows.WindowManager;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//org.nemesis.debug.ui.trackable//Trackables//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "TrackablesTopComponent",
        iconBase = "org/nemesis/debug/ui/trackable/pig.png",
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "output", openAtStartup = true)
@ActionID(category = "Window", id = "org.nemesis.debug.ui.trackable.TrackablesTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_TrackablesAction",
        preferredID = "TrackablesTopComponent"
)
@Messages({
    "CTL_TrackablesAction=Trackables",
    "CTL_TrackablesTopComponent=Trackables",
    "HINT_TrackablesTopComponent=Shows status of objects which should be cleaned up but might not be"
})
public final class TrackablesTopComponent extends TopComponent implements Consumer<Set<? extends Trackables.TrackingReference<?>>>, ActionListener {

    private final DefaultListModel<Trackables.TrackingReference<?>> mdl
            = new DefaultListModel<>();

    private final Timer timer = new Timer(3000, this);
    private final RequestProcessor p = new RequestProcessor("refs");
    private final Set<String> knownMimeTypes = ConcurrentHashMap.newKeySet();

    public TrackablesTopComponent() {
        initComponents();
        setName(Bundle.CTL_TrackablesTopComponent());
        setToolTipText(Bundle.HINT_TrackablesTopComponent());
        putClientProperty(TopComponent.PROP_KEEP_PREFERRED_SIZE_WHEN_SLIDED_IN, Boolean.TRUE);
        jList1.setModel(mdl);
        jList1.setCellRenderer(new Ren());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        repaint();
    }

    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList<>();

        jList1.setModel(mdl);
        jList1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                lisrClick(evt);
            }
        });
        jScrollPane1.setViewportView(jList1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void lisrClick(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_lisrClick
        Set<Object> omit = new HashSet<>();
        omit.add(this);
        omit.add(mdl);
        DefaultListModel<?> m = AntlrPluginDebugTopComponent.model();
        if (m != null) {
            omit.add(m);
        }
        if (evt.getClickCount() > 1) {
            int ix = jList1.locationToIndex(evt.getPoint());
            if (ix >= 0 && ix < mdl.size()) {
                Trackables.TrackingReference<?> item = mdl.elementAt(ix);
                if (item != null) {
                    Object o = item.get();
                    if (o != null) {
                        StatusDisplayer.getDefault().setStatusText(
                                "Scanning for references: " + item);
                        p.post(() -> {
                            try {
                                Map<String, Object> roots = new HashMap<>();
                                roots.put("Default Lookup", Lookup.getDefault());
                                FileObject editors = FileUtil.getConfigFile("Editors/text");
                                if (editors != null) {
                                    for (FileObject fo : editors.getChildren()) {
                                        if (fo.isFolder()) {
                                            String mime = "text/" + fo.getName();
                                            try {
                                                roots.put(mime, MimeLookup.getLookup(mime));
                                            } catch (Exception e) {
                                                // ignore
                                            }
                                        }
                                    }
                                }
                                List<String> refs
                                        = ReferencesFinder.detect(o, roots, omit);
                                if (!refs.isEmpty()) {
                                    EventQueue.invokeLater(() -> {
                                        RefsTopComponent tc = new RefsTopComponent(item, refs);
                                        tc.open();
                                        tc.requestActive();
                                    });
                                } else {
                                    StatusDisplayer.getDefault().setStatusText("No references found");
                                }
                            } catch (Exception | Error e) {
                                e.printStackTrace();
                            }
                        });
                    }
                }
            }
        }
    }//GEN-LAST:event_lisrClick

    static final class RefsTopComponent extends TopComponent {

        private final String shortName;

        RefsTopComponent(Trackables.TrackingReference<?> t, List<String> refs) {
            shortName = t.toString();
            setDisplayName("Refs-" + shortName);
            JTextArea area = new JTextArea(Strings.join('\n', refs));
            area.setLineWrap(true);
            area.setWrapStyleWord(true);
            area.setEditable(false);
            area.setFont(UIManager.getFont("controlFont"));
            setLayout(new BorderLayout());
            JScrollPane pane = new JScrollPane(area);
            add(pane, BorderLayout.CENTER);
            pane.setBorder(BorderFactory.createEmptyBorder());
            pane.setViewportBorder(BorderFactory.createEmptyBorder());
        }

        @Override
        public void open() {
            Mode mode = WindowManager.getDefault().findMode("output");
            if (mode != null) {
                mode.dockInto(this);
            }
            super.open();
        }

        @Override
        public int getPersistenceType() {
            return PERSISTENCE_NEVER;
        }

        @Override
        public String getShortName() {
            return shortName;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList<Trackables.TrackingReference<?>> jList1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        Trackables.listen(this);
        timer.start();
    }

    @Override
    public void componentClosed() {
        timer.stop();
        Trackables.unlisten(this);
        mdl.clear();
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }

    @Override
    public void accept(Set<? extends Trackables.TrackingReference<?>> t) {
        EventQueue.invokeLater(() -> {
            if (isDisplayable()) {
                updateModel(t);
            }
        });
    }

    private void updateModel(Set<? extends Trackables.TrackingReference<?>> t) {
        Trackables.TrackingReference<?> oldSel = jList1.getSelectedValue();
        List<Trackables.TrackingReference<?>> l = new ArrayList<>(t);
        Set<Trackables.TrackingReference<?>> discard = new HashSet<>();
        Set<Trackables.TrackingReference<?>> keep = new HashSet<>();
        for (int i = 0; i < mdl.size(); i++) {
            Trackables.TrackingReference<?> item = mdl.elementAt(i);
            if (item.isAlive()) {
                keep.add(item);
            } else {
                discard.add(item);
            }
        }
        l.addAll(keep);
        mdl.clear();
        Collections.sort(l, (a, b) -> {
            int result = a.type().getName().compareTo(b.type().getName());
            if (result == 0) {
                result = a.compareTo(b);
            }
            return result;
        });
        int selIx = -1;
        for (int i = 0; i < l.size(); i++) {
            Trackables.TrackingReference<?> item = l.get(i);
            if (oldSel == item) {
                selIx = i;
            }
            mdl.addElement(item);
        }
        if (selIx >= 0) {
            jList1.setSelectedIndex(selIx);
        }
    }

    static final class Ren implements ListCellRenderer<Trackables.TrackingReference<?>> {

        private final HtmlRenderer.Renderer ren = HtmlRenderer.createRenderer();

        @Override
        public Component getListCellRendererComponent(JList<? extends Trackables.TrackingReference<?>> list, Trackables.TrackingReference<?> value, int index, boolean isSelected, boolean cellHasFocus) {
            String valueText = value.toString();
            if (value.isAlive()) {
                valueText = "<b>" + valueText;
            }
            ren.setHtml(true);
            Component result = ren.getListCellRendererComponent(list, valueText, index, isSelected, cellHasFocus);
            ren.setHtml(true);
            ren.setText(valueText);
            return result;
        }
    }
}
