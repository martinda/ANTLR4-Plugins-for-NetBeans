package org.nemesis.antlr.project;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.CompletionStage;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.nemesis.antlr.project.impl.AntlrConfigurationFactory;
import org.nemesis.antlr.project.impl.FoldersHelperTrampoline;
import org.nemesis.antlr.project.spi.NewAntlrConfigurationInfo;
import org.nemesis.antlr.projectupdatenotificaton.ProjectUpdates;
import org.netbeans.api.project.FileOwnerQuery;
import org.netbeans.api.project.Project;
import org.netbeans.api.project.ProjectManager;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;

/**
 * Antlr configuration for a project, specifying folders and locations for
 * various things.
 *
 * @author Tim Boudreau
 */
public final class AntlrConfiguration {

    private final Path importDir;
    private final Path sourceDir;
    private final Path outputDir;
    private final boolean listener;
    private final boolean visitor;
    private final boolean atn;
    private final boolean forceATN;
    private final String includePattern;
    private final String excludePattern;
    private final Charset encoding;
    private final Path buildDir;
    private final String createdByStrategy;
    private final boolean isGuessedConfig;
    private final Path buildOutput;
    private final Path testOutput;
    private final Path sources;
    private final Path testSources;

    AntlrConfiguration(Path importDir, Path sourceDir, Path outDir, boolean listener, boolean visitor,
            boolean atn, boolean forceATN, String includePattern, String excludePattern, Charset encoding,
            Path buildDir, String createdByStrategy, boolean isGuessedConfig,
            Path buildOutput, Path testOutput, Path sources, Path testSources) {
        this.importDir = importDir;
        this.sourceDir = sourceDir;
        this.outputDir = outDir;
        this.listener = listener;
        this.visitor = visitor;
        this.atn = atn;
        this.forceATN = forceATN;
        this.includePattern = includePattern;
        this.excludePattern = excludePattern;
        this.encoding = encoding;
        this.buildDir = buildDir;
        this.createdByStrategy = createdByStrategy;
        this.isGuessedConfig = isGuessedConfig;
        this.buildOutput = buildOutput;
        this.testOutput = testOutput;
        this.sources = sources;
        this.testSources = testSources;
    }

    public boolean isImportDirChildOfSourceDir() {
        if (sourceDir == null || importDir == null) {
            return false;
        }
        return importDir.startsWith(sourceDir);
    }

    public static boolean isAntlrProject(Project project) {
        boolean result = FoldersHelperTrampoline.getDefault().isRecognized(project);
        if (result) {
            AntlrConfiguration config = forProject(project);
            result = config != null && !config.isGuessedConfig
                    && config.sourceDir != null && Files.exists(config.sourceDir);
        }
        return result;
    }

    public static Set<Path> potentialBuildFilePaths(Project project) {
        if (project == null) {
            return Collections.emptySet();
        }
        File f = FileUtil.toFile(project.getProjectDirectory());
        if (f == null) {
            return Collections.emptySet();
        }
        Path projectPath = f.toPath();
        Set<Path> result = new HashSet<>();
        for (Path p : FoldersHelperTrampoline.getDefault().buildFileRelativePaths()) {
            result.add(projectPath.resolve(p));
        }
        return result;
    }

    public Path buildOutput() {
        return buildOutput;
    }

    public Path testOutput() {
        return testOutput;
    }

    public Path javaSources() {
        return sources;
    }

    public Path testSources() {
        return testSources;
    }

    /**
     * If true, this is an approximated config generated by heuristic (and may
     * return null for some folder types).
     *
     * @return Whether or not the configuration is guessed
     */
    public boolean isGuessedConfig() {
        return isGuessedConfig;
    }

    /**
     * Name of the project-type plugin that created this config, for logging
     * purposes.
     *
     * @return A name
     */
    public String createdBy() {
        return createdByStrategy;
    }

    private static final Map<Project, AntlrConfiguration> CACHE = Collections.synchronizedMap(new WeakHashMap<>());
    private static volatile boolean LISTENING;
    private static final Consumer<Path> PROJECT_MOD_LISTENER = path -> {
        FileObject fo = FileUtil.toFileObject(FileUtil.normalizeFile(path.toFile()));
        if (fo != null) {
            Project prj;
            try {
                prj = ProjectManager.getDefault().findProject(fo);
                CACHE.remove(prj);
            } catch (IOException ioe) {
                Logger.getLogger(AntlrConfiguration.class.getName()).log(Level.SEVERE, path.toString(), ioe);
            }
        }
    };

    public static AntlrConfiguration forProject(Project project) {
        AntlrConfiguration config = CACHE.get(project);
        if (config == null) {
            config = FoldersLookupStrategy.get(project).antlrConfig();
            if (config != null) {
                CACHE.put(project, config);
            }
            if (!LISTENING) {
                LISTENING = true;
                ProjectUpdates.subscribeToChanges(PROJECT_MOD_LISTENER);
            }
        }
        return config;
    }

    public static AntlrConfiguration forFile(FileObject file) {
        return FoldersLookupStrategy.get(FileOwnerQuery.getOwner(file)).antlrConfig();
    }

    public static AntlrConfiguration forFile(Path file) {
        return forFile(FileUtil.toFileObject(FileUtil.normalizeFile(file.toFile())));
    }

    public Path antlrImportDir() {
        return importDir;
    }

    public Path antlrSourceDir() {
        return sourceDir;
    }

    public Path antlrSourceOutputDir() {
        return outputDir;
    }

    public Path buildDir() {
        return buildDir;
    }

    public Charset encoding() {
        return encoding;
    }

    public String includePattern() {
        return includePattern;
    }

    public String excludePattern() {
        return excludePattern;
    }

    public boolean listener() {
        return listener;
    }

    public boolean visitor() {
        return visitor;
    }

    public boolean atn() {
        return atn;
    }

    public boolean forceATN() {
        return forceATN;
    }

    /**
     * Get a function which can add Antlr support to the passed project, if a
     * module has registered an object which can modify the build file
     * appropriately, and if the project does not already have Antlr support.
     *
     * @param prj The project
     * @return A function or null if support cannot be added
     */
    public static Function<NewAntlrConfigurationInfo, CompletionStage<Boolean>> antlrAdder(Project prj) {
        return FoldersHelperTrampoline.antlrAdder(prj);
    }

    @Override
    public String toString() {
        return "AntlrPluginInfo{\n" + " importDir\t" + importDir
                + "\n sourceDir\t" + sourceDir + "\n outputDir\t" + outputDir
                + "\n listener\t" + listener + "\n visitor\t" + visitor
                + "\n atn\t" + atn + "\n forceATN\t" + forceATN
                + "\n includePattern\t" + includePattern
                + "\n excludePattern\t" + excludePattern
                + "\n encoding\t" + encoding.name()
                + "\n buildDir\t" + buildDir
                + "\n createdBy\t" + createdByStrategy
                + "\n sources\t" + sources
                + "\n testSources\t" + testSources
                + "\n buildOutput\t" + buildOutput
                + "\n testOutput\t" + testOutput
                + "\n}";
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 53 * hash + Objects.hashCode(this.importDir);
        hash = 53 * hash + Objects.hashCode(this.sourceDir);
        hash = 53 * hash + Objects.hashCode(this.outputDir);
        hash = 53 * hash + (this.listener ? 1 : 0);
        hash = 53 * hash + (this.visitor ? 1 : 0);
        hash = 53 * hash + (this.atn ? 1 : 0);
        hash = 53 * hash + (this.forceATN ? 1 : 0);
        hash = 53 * hash + Objects.hashCode(this.includePattern);
        hash = 53 * hash + Objects.hashCode(this.excludePattern);
        hash = 53 * hash + Objects.hashCode(this.encoding);
        hash = 53 * hash + Objects.hashCode(this.buildDir);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final AntlrConfiguration other = (AntlrConfiguration) obj;
        if (this.listener != other.listener) {
            return false;
        }
        if (this.visitor != other.visitor) {
            return false;
        }
        if (this.atn != other.atn) {
            return false;
        }
        if (this.forceATN != other.forceATN) {
            return false;
        }
        if (!Objects.equals(this.includePattern, other.includePattern)) {
            return false;
        }
        if (!Objects.equals(this.excludePattern, other.excludePattern)) {
            return false;
        }
        if (!Objects.equals(this.importDir, other.importDir)) {
            return false;
        }
        if (!Objects.equals(this.sourceDir, other.sourceDir)) {
            return false;
        }
        if (!Objects.equals(this.outputDir, other.outputDir)) {
            return false;
        }
        if (!Objects.equals(this.encoding, other.encoding)) {
            return false;
        }
        return Objects.equals(this.buildDir, other.buildDir);
    }

    private static final class DefaultConfigFactory extends AntlrConfigurationFactory {

        @Override
        protected AntlrConfiguration create(Path importDir, Path sourceDir,
                Path outDir, boolean listener, boolean visitor, boolean atn,
                boolean forceATN, String includePattern, String excludePattern,
                Charset encoding, Path buildDir, String createdBy,
                boolean isGuessedConfig, Path buildOutput, Path testOutput, Path sources, Path testSources) {
            return new AntlrConfiguration(importDir, sourceDir, outDir, listener,
                    visitor, atn, forceATN, includePattern, excludePattern,
                    encoding, buildDir, createdBy, isGuessedConfig, buildOutput,
                    testOutput, sourceDir, testSources);
        }
    }

    static {
        FoldersHelperTrampoline.antlrConfigFactory = new DefaultConfigFactory();
    }
}
