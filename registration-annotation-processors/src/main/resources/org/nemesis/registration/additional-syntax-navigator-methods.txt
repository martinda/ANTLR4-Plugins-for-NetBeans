private static boolean ruleToString(ParserRuleContext ctx, BiPredicate<String, ParserRuleContext> bi) {
        String nm = ctx.getClass().getSimpleName();
        if (nm.endsWith("Context")) {
            nm = nm.substring(0, nm.length() - 7);
        }
        Token start = ctx.getStart();
        Token stop = ctx.getStop();
        if (start != null && (start == stop || start.equals(stop))) {
            if (!hasRuleChildren(ctx)) {
                String text = start.getText();
                if (text.length() > 15) {
                    text = text.substring(0, 15) + "\u2026";
                }
                return bi.test("<b>" + escapeHtml(text) + "</b> <font color=\"!controlShadow\">" + nm, ctx);
            }
        }
        try {
            return bi.test(nm, ctx);
        } catch (IllegalArgumentException ex) {
            java.util.logging.Logger logger = java.util.logging.Logger.getLogger("org.nemesis.SyntaxTreeNavigator");
            logger.log(java.util.logging.Level.INFO, "Likely range add out of order adding "
                    + nm + " - " + ctx + " from " + start.getStartIndex()
                    + " to " + stop.getStopIndex(), ex);
        }
        return false;
    }

    private static boolean hasRuleChildren(ParserRuleContext ctx) {
        int max = ctx.getChildCount();
        for ( int i = 0; i < max; i++ ) {
            ParseTree tree = ctx.getChild( i );
            if ( tree instanceof ParserRuleContext ) {
                return true;
            }
        }
        return false;
    }

    private static String escapeHtml(String val) {
        StringBuilder sb = new StringBuilder(val.length() + 10);
        for (int i=0; i < val.length(); i++) {
            char c = val.charAt(i);
            switch(c) {
                case '"' :
                    sb.append("&quot;");
                    break;
                case '<' :
                    sb.append("&lt;");
                    break;
                case '>':
                    sb.append("&gt;");
                    break;
                default :
                    sb.append(c);
            }
        }
        return sb.toString();
    }
