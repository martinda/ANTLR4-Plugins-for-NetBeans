/*
 * Copyright 2016-2019 Tim Boudreau, Frédéric Yvon Vinet
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.nemesis.data;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Allows us to hash a GenericExtractorBuilder and its contents in a detailed
 * way, so if extractions are cached on disk, and the code changes, we don't
 * load caches that were generated by a differently configured extractor, since
 * those contents will not be what the code now expects.
 * <p>
 * For the purposes we use this for, this code does what it is supposed to with
 * Lambdas, <i>assuming the lambdas used to create the extractor are static
 * method references, and not instance methods of an object whose
 * toString()/hashCode() will differ across runs.</i>. The only thing we are
 * interested in here is always producing the same hash value if <i>the same
 * code</i> constructed it.
 * </p>
 * If you use custom types which are not lambdas for callbacks, or other custom
 * types in builders for creating an extraction, ensure that their hashCode()
 * and toString() are consistent, or the implement Hashable and hash the same
 * way if they have the same configuration. For stateless lambdas - static
 * methods invoked by reference, the result will always hash correctly. If there
 * is some state, you may want to implement the functional interface as a class,
 * implement Hashable and encode the state in the hash, to guarantee valid
 * comparisons.
 *
 * @author Tim Boudreau
 */
public interface Hashable {

    default void hashInto(Hasher hasher) {
        // Not great for lambdas, but short of serializable and serializing
        // them, will have to do
        hasher.writeString(toString());
    }

    static Hasher newHasher() {
        return new Hasher();
    }

    public static final class Hasher {

        private final ByteArrayOutputStream out = new ByteArrayOutputStream(1_024);
        private static final Logger LOG = Logger.getLogger(Hasher.class.getName());

        Hasher() {
        }

        @Override
        public String toString() {
            return new String(out.toByteArray(), UTF_8);
        }

        public Hasher hashObject(Object obj) {
            if (obj == null) {
                writeInt(0);
                return this;
            }
            if (obj instanceof Hashable) {
                ((Hashable) obj).hashInto(this);
            } else if (obj instanceof Enum<?>) {
                Enum<?> e = (Enum<?>) obj;
                writeInt(e.ordinal());
                writeInt(e.getClass().hashCode());
            } else {
                writeInt(obj.hashCode());
                writeString(obj.toString());
            }
            return this;
        }

        public String hash() {
            try {
                MessageDigest md = MessageDigest.getInstance("SHA-1");
                byte[] digest = md.digest(out.toByteArray());
                return Base64.getUrlEncoder().encodeToString(digest);
            } catch (NoSuchAlgorithmException ex) {
                LOG.log(Level.SEVERE, null, ex);
            }
            return null;
        }

        public Hasher writeIntArray(int[] vals) {
            ByteBuffer bb = ByteBuffer.allocate(vals.length * (Integer.SIZE / 8));
            for (int i = 0; i < vals.length; i++) {
                bb.putInt(i);
            }
            try {
                out.write(bb.array());
            } catch (IOException ex) {
                LOG.log(Level.SEVERE, null, ex);
            }
            return this;
        }

        public Hasher writeString(String val) {
            try {
                out.write(val.getBytes(UTF_8));
            } catch (IOException ex) {
                LOG.log(Level.SEVERE, null, ex);
            }
            return this;
        }

        public Hasher writeInt(int val) {
            ByteBuffer bb = ByteBuffer.allocate(Integer.SIZE / 8);
            bb.putInt(val);
            try {
                out.write(bb.array());
            } catch (IOException ex) {
                LOG.log(Level.SEVERE, null, ex);
            }
            return this;
        }
    }
}
